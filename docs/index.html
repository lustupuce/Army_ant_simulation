<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Army ant simulation: Army ant simulation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Army ant simulation
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Army ant simulation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro_sec"></a>
Introduction</h1>
<p>The first objective of this simulator is to try to replicate army ant bridge formation with flipping biped robots. The simulator can be used to help determining the parameters that influence the bridge formation. It also allows to try several basic rules on the simulated robots quickly. The simulator is working in 2D and combines 2 main libraries:</p><ul>
<li>The physics is handled by Box2D: <a href="https://box2d.org/about/">https://box2d.org/about/</a></li>
<li>The graphics portion is done using SFML: <a href="https://www.sfml-dev.org">https://www.sfml-dev.org</a></li>
</ul>
<p>However, both libraries does not use the same origin. Indeed. while the SFML (graphic) origin of the shapes is on the top left corner, the Box2D (physics) origin is set at the middle of the shape.<br />
 (cf image below) </p><div class="image">
<img src="box2d_vs_sfml.png" alt="box2d_vs_sfml.png"/>
</div>
<p> In addition, while in SFML all the positions are given in the world reference frame, the Box2D positions can be obtained either in the world reference frame our in their local reference frame (the shape from where the position is asked)<br />
 More importantly, the Box2D dimensions are given in meters while the SFML ones are given in pixel: to go from one to the other the conversion has to be carefully done Thus, if it is possible to do all the transformation from the Box2D position to the SFML ones manually, it is usually easier to proceed as following:</p><ul>
<li>Create the Box2D shape attached to a body</li>
<li>Get the position of its top left corner in the world reference frame from the local reference frame <br />
</li>
<li>Create the SFML corresponding shape at the position obtained previously<br />
 BE CAREFUL: the dimension also has to be converted from meters to pixel when going from Box2D to SFML<br />
<br />
 A concrete example to create a rectangle of width w and height h located at (posX, posY) is described below : <div class="fragment"><div class="line"><span class="comment">// Create the Box2D body (no fixture and shape attached yet)</span></div><div class="line">b2BodyDef rectBodyDef;</div><div class="line">rectBodyDef.position = b2Vec2(posX, posY);</div><div class="line">rectBody = world-&gt;CreateBody(&amp;rectBodyDef);</div><div class="line"></div><div class="line"><span class="comment">// Create the Box2D fixture and the rectangular shape that will be attached to the body</span></div><div class="line">b2PolygonShape rectShape;</div><div class="line">rectShape.SetAsBox(w/2,h/2);</div><div class="line">b2FixtureDef rectFixtureDef;</div><div class="line">rectFixtureDef.shape = &amp;rectShape;</div><div class="line">rectBody-&gt;CreateFixture(&amp;rectFixtureDef);</div><div class="line"></div><div class="line"><span class="comment">// Get the top left corner position in the world frame</span></div><div class="line">b2Vec2 topLeft = rect_box2D-&gt;GetWorldPoint(b2Vec2(-w/2,-h/2));</div><div class="line"></div><div class="line"><span class="comment">// Create the corresponding SFML shape</span></div><div class="line">sf::RectangleShape rectShape_sfml(sf::Vector2f(w*m_to_pix, h*m_to_pix));</div><div class="line">rectShape_sfml.setPosition(m_to_pix*topLeft.x,m_to_pix*topLeft.y);</div></div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="struct"></a>
Code overview</h1>
<p>To launch a simulation with existing terrains and without modifying the intrinsic properties of the robots or the controller, only the <a class="el" href="a00032.html">main.cpp</a> and <a class="el" href="a00020_source.html">Demo.cpp</a> file should be modified. In addition, the simulator has not been implemented as a library and the main program is mixed with background source code. Thus it is better to start from the existing main file (and modifying it) than creating a new one. Indeed, the main file also implements the basic function to parse the arguments to launch a simulation and the help function. </p><dl class="section note"><dt>Note</dt><dd>A future improvement of the code could be to transform the code so that it can be used as a library (with for eg a simulation class which would be initiated with the configuration parameters). However, it will require to find a way to give the terrain type as an entry parameter.</dd></dl>
<h1><a class="anchor" id="param"></a>
Configuration parameters</h1>
<p>The configuration parameters are defined in <a class="el" href="a00014.html" title="Implementation of the Configuration class used to parse the configuration file and the sConfig struct...">Config.h</a>. There is several way for the user to specify the input parameters. An easy way to do so when just launching the simulation from the IDE (eg:eclipse) is to modify the default parameters value in <a class="el" href="a00032.html#a075854c1227ffd274988d62bb5c859a1">default_parameters(config::sConfig&amp; cfg)</a> (in <a class="el" href="a00032.html">main.cpp</a>).<br />
 Another proper way to specify the configuration parameters is to write them in a config file and launch the simulation from the terminal specifying the configuration path : -cp &lt;path&gt;. An example of configuration file is given under examples/config_template.cfg.<br />
 However, if one want to launch a batch of simulation with different values for the parameters. It might be easier to specify the parameters values individually with the correct entry command. The list of command can be obtain when launching the simulation from the terminal: "./Simulation_v2 -h " or "./Simulation_v2 --help" <br />
 From the source code, the commands are summarized in <a class="el" href="a00032.html#a97ee70a8770dc30d06c744b24eb2fcfc">help()</a> (in <a class="el" href="a00032.html">main.cpp</a>)</p>
<h1><a class="anchor" id="terrain"></a>
Create the terrain</h1>
<p>Different type of terrain are already implemented. <br />
 The Default terrain is the one implemented in the parent class <a class="el" href="a00137.html">Terrain</a>. It is a simple horizontal ground.<br />
 The <a class="el" href="a00085.html">BoxTerrain</a> is an horizontal rectangular box.<br />
 The <a class="el" href="a00149.html">Vterrain</a> is an horizontal ground with a V-shaped gap.<br />
 The <a class="el" href="a00141.html">V2BLTerrain</a> is similar to the <a class="el" href="a00149.html">Vterrain</a> but the bottom of the V-shaped gap is truncated so that the width corresponds to 2 body-length.<br />
 The <a class="el" href="a00125.html">Ramp</a> is a single descending ramp (with a 90° angle).<br />
 The <a class="el" href="a00145.html">VStepper</a> is a more complex terrain where the obstacle is kind of a stepper but with sharper angle (angle &lt; 90°).<br />
 </p>
<h2><a class="anchor" id="ex_terrain"></a>
Existing terrain</h2>
<p>To select which terrain should be used in the simulation, it has to be specified in the <a class="el" href="a00023.html" title="Implementation of the Demo class and the MyContactListener_v2 class. ">Demo.h</a> file: the type of the Demo::m_terrain member has to be adapted. Once the terrain has been chosen, the terrain Parameters (cf sTerrain struct in <a class="el" href="a00014.html" title="Implementation of the Configuration class used to parse the configuration file and the sConfig struct...">Config.h</a>) can be adjusted using different methods described in <a class="el" href="index.html#param">Configuration parameters</a></p>
<h2><a class="anchor" id="new_terrain"></a>
Create new terrain</h2>
<p>If the creation of a new terrain is necessary, the new class should inherit from the global <a class="el" href="a00137.html">Terrain</a> class. then the newly created .h file should be included in <a class="el" href="a00023.html" title="Implementation of the Demo class and the MyContactListener_v2 class. ">Demo.h</a>.<br />
 It might be necessary to re-implement the getScale() function depending on the parameters so that the whole terrain fits the window size.<br />
</p>
<h1><a class="anchor" id="rob"></a>
Create robots</h1>
<p>The robot flow is either by a given delay between the robots and initial position or a given distance between the robots and phase shift. The way the robots are created is controlled in the <a class="el" href="a00020_source.html">Demo.cpp</a> file by choosing which function is used in <a class="el" href="a00121.html#a938c3b6ab1c98ce43f977dda9d4f2b3a">Demo::demoLoop()</a>. It can be either <a class="el" href="a00121.html#a4636f708574c6be85334ff16373e2292">Demo::addRobotWithDelay()</a> to control the robot creation with a given delay or <a class="el" href="a00121.html#a37b03d288a1bf67f586cdfe1f9ba16af">Demo::addRobotWithDistance()</a> to control the robot creation with a given distance. Then the distance, delay, phase, initial position are specified in the sSimulation <a class="el" href="index.html#param">Configuration parameters</a>. <br />
 </p>
<h2><a class="anchor" id="rob_del"></a>
Custom robot delay distribution</h2>
<p>By default, the delay (or distance) between the robots follow a constant distribution (ie the distance/ delay is identical between every successive robots). In certain cases, it can be interesting to customize the distribution for example to study the introduction of perturbation. A way to do so without modifying to much the code structure is to update m_config.simulation.robot_delay (respectively m_config.simulation.robot_distance) directly in the <a class="el" href="a00020_source.html">Demo.cpp</a> file at every timestep (either within a newly created function or directly in the <a class="el" href="a00121.html#a938c3b6ab1c98ce43f977dda9d4f2b3a">Demo::demoLoop()</a> one).<br />
 <br />
 Currently, two different delay distribution have been briefly implemented:</p><ul>
<li>Gaussian delay: the gaussian delay is selected by setting gaussian_delay to true at the top of the <a class="el" href="a00020_source.html">Demo.cpp</a> file.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Future work might require to properly implement a function which would allow to choose the delay distribution. Maybe, the creation of a robot delay class can be considered.</dd></dl>
<h1><a class="anchor" id="rules"></a>
Change the rules</h1>
<p>The rules can be adapted at several positions</p><ul>
<li>The limit angle to avoid pushing is given as a <a class="el" href="index.html#param">Configuration parameters</a> and can be changed the usual way.</li>
</ul>
<h1><a class="anchor" id="design"></a>
Design details</h1>
<ul>
<li>The minimum angle before which no gripper can be created (to avoid re-gripping the exact same position) can be changed in the <a class="el" href="a00133.html">RobotController</a> Class by changing the value of the m_angle_min member</li>
<li>gripping area</li>
<li>max number of grippers per foot</li>
<li>mobility in bridge state</li>
</ul>
<h1><a class="anchor" id="ex"></a>
Step by Step example</h1>
<p>As briefly explained in the <a class="el" href="index.html#struct">Code overview</a>, currently, the simulation should be adapted by changing directly the main function of the <a class="el" href="a00032.html">main.cpp</a> file and adapt the <a class="el" href="a00020_source.html">Demo.cpp</a> / <a class="el" href="a00023.html" title="Implementation of the Demo class and the MyContactListener_v2 class. ">Demo.h</a> files. The basic steps are described below</p>
<p>In <a class="el" href="a00032.html">main.cpp</a> : </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> <a class="code" href="a00032.html#a0ddf1224851353fc92bfbff6f499fa97">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])</div><div class="line">{</div><div class="line"></div><div class="line"> <span class="comment">// Declaration and initialization of the variables</span></div><div class="line"> <span class="keywordtype">bool</span> config_file = <span class="keyword">false</span>;</div><div class="line"> std::string config_file_path;</div><div class="line"> <a class="code" href="a00109.html">config::sConfig</a> configParam;</div><div class="line"> <a class="code" href="a00032.html#a075854c1227ffd274988d62bb5c859a1">default_parameters</a>(configParam);</div><div class="line"></div><div class="line"> <span class="comment">// The first step is to create the Box2D world (and choose the gravity)</span></div><div class="line"> b2Vec2 Gravity(0.f, 0.f);</div><div class="line"> b2World* world = <span class="keyword">new</span> b2World(Gravity);</div><div class="line"></div><div class="line"> <span class="comment">// The second step is to parse the arguments. This function is generic and should not be changed</span></div><div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; argc; i++) { <span class="comment">/* We will iterate over argv[] to get the parameters stored inside.</span></div><div class="line"><span class="comment">                                      * Note that we&#39;re starting on 1 because we don&#39;t need to know the</span></div><div class="line"><span class="comment">                                      * path of the program, which is stored in argv[0] */</span></div><div class="line">     <span class="keywordflow">if</span> (std::string(argv[i]) == <span class="stringliteral">&quot;-h&quot;</span> || std::string(argv[i]) == <span class="stringliteral">&quot;--help&quot;</span>) {</div><div class="line">       printf(<span class="stringliteral">&quot;tetetete \n&quot;</span>);</div><div class="line">       <a class="code" href="a00032.html#a97ee70a8770dc30d06c744b24eb2fcfc">help</a>();</div><div class="line">       <span class="keywordflow">return</span> 0;</div><div class="line">     }</div><div class="line">     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (i + 1 != argc){</div><div class="line">              <span class="comment">// The first thing to check is whether a configuration file has been specified</span></div><div class="line">       <span class="keywordflow">if</span> (std::string(argv[i]) == <span class="stringliteral">&quot;-cp&quot;</span> || std::string(argv[i]) == <span class="stringliteral">&quot;--configuration_path&quot;</span>) {</div><div class="line">              <span class="comment">// We know the next argument *should* be the filename:</span></div><div class="line">              config_file_path = std::string(argv[i + 1]);</div><div class="line">               config_file = <span class="keyword">true</span>;</div><div class="line">                load_config(config_file_path, configParam);</div><div class="line">                 <span class="keywordflow">break</span>;</div><div class="line">       }</div><div class="line">       <span class="keywordflow">else</span>{</div><div class="line">         parse_argument(argv, i, configParam);</div><div class="line">       }</div><div class="line">     }</div><div class="line"></div><div class="line">     <span class="keywordflow">if</span>(configParam.terrain.v_angle &gt; 0){</div><div class="line">       configParam.terrain.v_width = tan(configParam.terrain.v_angle)*2*configParam.terrain.v_height;</div><div class="line">     }</div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="comment">//The third step is to create the Demo, initiate it, launch it and write the results once it&#39;s finished</span></div><div class="line"> <a class="code" href="a00121.html">Demo</a> myDemo(world, configParam);</div><div class="line"> myDemo.init();</div><div class="line"> myDemo.demoLoop();</div><div class="line"> myDemo.writeResultFile();</div><div class="line"></div><div class="line"> <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p>In <a class="el" href="a00023.html" title="Implementation of the Demo class and the MyContactListener_v2 class. ">Demo.h</a>: change the terrain type </p><div class="fragment"><div class="line"><a class="code" href="a00085.html">BoxTerrain</a> m_terrain; <span class="comment">//Terrain used to do the simulation, the object can be changed to either: Terrain, BoxTerrain, Vterrain, V2BLTerrain, VStepper</span></div></div><!-- fragment --><p>In <a class="el" href="a00020_source.html">Demo.cpp</a>: choose how the robots are created in the <a class="el" href="a00121.html#a938c3b6ab1c98ce43f977dda9d4f2b3a">Demo::demoLoop()</a> : either with a given distance or a given delay in the main demoLoop. Be careful, you have to change at two distinct positions: in the first part of the loop when the visualization is activated and in the second part of the loop when the visualization is deactivated </p><div class="fragment"><div class="line">     <span class="comment">//This is where the traffic control is defined: either using addRobotWithDelay() or addRobotWithDistance()</span></div><div class="line">                <span class="keywordflow">if</span>(!addRobotWithDelay()){</div><div class="line">                    m_stacking = <span class="keyword">true</span>;</div><div class="line">                    printf(<span class="stringliteral">&quot;robot stacking \n&quot;</span>);</div><div class="line"><span class="comment">//                  m_bridgeFile.close();</span></div><div class="line">                    <span class="keywordflow">continue</span>;</div><div class="line">                }</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
