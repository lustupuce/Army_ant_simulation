\hypertarget{index_intro_sec}{}\section{Introduction}\label{index_intro_sec}
The first objective of this simulator is to try to replicate army ant bridge formation with flipping biped robots. The simulator can be used to help determining the parameters that influence the bridge formation. It also allows to try several basic rules on the simulated robots quickly. The simulator is working in 2D and combines 2 main libraries\+:
\begin{DoxyItemize}
\item The physics is handled by Box2D\+: \href{https://box2d.org/about/}{\tt https\+://box2d.\+org/about/}
\item The graphics portion is done using S\+F\+ML\+: \href{https://www.sfml-dev.org}{\tt https\+://www.\+sfml-\/dev.\+org}
\end{DoxyItemize}

However, both libraries does not use the same origin. Indeed. while the S\+F\+ML (graphic) origin of the shapes is on the top left corner, the Box2D (physics) origin is set at the middle of the shape.~\newline
 (cf image below)  In addition, while in S\+F\+ML all the positions are given in the world reference frame, the Box2D positions can be obtained either in the world reference frame our in their local reference frame (the shape from where the position is asked)~\newline
 More importantly, the Box2D dimensions are given in meters while the S\+F\+ML ones are given in pixel\+: to go from one to the other the conversion has to be carefully done Thus, if it is possible to do all the transformation from the Box2D position to the S\+F\+ML ones manually, it is usually easier to proceed as following\+:
\begin{DoxyItemize}
\item Create the Box2D shape attached to a body
\item Get the position of its top left corner in the world reference frame from the local reference frame ~\newline

\item Create the S\+F\+ML corresponding shape at the position obtained previously~\newline
 BE C\+A\+R\+E\+F\+UL\+: the dimension also has to be converted from meters to pixel when going from Box2D to S\+F\+ML~\newline
~\newline
 A concrete example to create a rectangle of width w and height h located at (posX, posY) is described below \+: 
\begin{DoxyCode}
\textcolor{comment}{// Create the Box2D body (no fixture and shape attached yet)}
b2BodyDef rectBodyDef;
rectBodyDef.position = b2Vec2(posX, posY);
rectBody = world->CreateBody(&rectBodyDef);

\textcolor{comment}{// Create the Box2D fixture and the rectangular shape that will be attached to the body}
b2PolygonShape rectShape;
rectShape.SetAsBox(w/2,h/2);
b2FixtureDef rectFixtureDef;
rectFixtureDef.shape = &rectShape;
rectBody->CreateFixture(&rectFixtureDef);

\textcolor{comment}{// Get the top left corner position in the world frame}
b2Vec2 topLeft = rect\_box2D->GetWorldPoint(b2Vec2(-w/2,-h/2));

\textcolor{comment}{// Create the corresponding SFML shape}
sf::RectangleShape rectShape\_sfml(sf::Vector2f(w*m\_to\_pix, h*m\_to\_pix));
rectShape\_sfml.setPosition(m\_to\_pix*topLeft.x,m\_to\_pix*topLeft.y);
\end{DoxyCode}

\end{DoxyItemize}\hypertarget{index_struct}{}\section{Code overview}\label{index_struct}
To launch a simulation with existing terrains and without modifying the intrinsic properties of the robots or the controller, only the \mbox{\hyperlink{main_8cpp}{main.\+cpp}} and Demo.\+cpp file should be modified. In addition, the simulator has not been implemented as a library and the main program is mixed with background source code. Thus it is better to start from the existing main file (and modifying it) than creating a new one. Indeed, the main file also implements the basic function to parse the arguments to launch a simulation and the help function. \begin{DoxyNote}{Note}
A future improvement of the code could be to transform the code so that it can be used as a library (with for eg a simulation class which would be initiated with the configuration parameters). However, it will require to find a way to give the terrain type as an entry parameter.
\end{DoxyNote}
\hypertarget{index_param}{}\section{Configuration parameters}\label{index_param}
The configuration parameters are defined in \mbox{\hyperlink{_config_8h}{Config.\+h}}. There is several way for the user to specify the input parameters. An easy way to do so when just launching the simulation from the I\+DE (eg\+:eclipse) is to modify the default parameters value in \mbox{\hyperlink{main_8cpp_a075854c1227ffd274988d62bb5c859a1}{default\+\_\+parameters(config\+::s\+Config\& cfg)}} (in \mbox{\hyperlink{main_8cpp}{main.\+cpp}}).~\newline
 Another proper way to specify the configuration parameters is to write them in a config file and launch the simulation from the terminal specifying the configuration path \+: -\/cp $<$path$>$. An example of configuration file is given under examples/config\+\_\+template.\+cfg.~\newline
 However, if one want to launch a batch of simulation with different values for the parameters. It might be easier to specify the parameters values individually with the correct entry command. The list of command can be obtain when launching the simulation from the terminal\+: \char`\"{}./\+Simulation\+\_\+v2 -\/h \char`\"{} or \char`\"{}./\+Simulation\+\_\+v2 -\/-\/help\char`\"{} ~\newline
 From the source code, the commands are summarized in \mbox{\hyperlink{main_8cpp_a97ee70a8770dc30d06c744b24eb2fcfc}{help()}} (in \mbox{\hyperlink{main_8cpp}{main.\+cpp}})\hypertarget{index_terrain}{}\section{Create the terrain}\label{index_terrain}
Different type of terrain are already implemented. ~\newline
 The Default terrain is the one implemented in the parent class \mbox{\hyperlink{class_terrain}{Terrain}}. It is a simple horizontal ground.~\newline
 The \mbox{\hyperlink{class_box_terrain}{Box\+Terrain}} is an horizontal rectangular box.~\newline
 The \mbox{\hyperlink{class_vterrain}{Vterrain}} is an horizontal ground with a V-\/shaped gap.~\newline
 The \mbox{\hyperlink{class_v2_b_l_terrain}{V2\+B\+L\+Terrain}} is similar to the \mbox{\hyperlink{class_vterrain}{Vterrain}} but the bottom of the V-\/shaped gap is truncated so that the width corresponds to 2 body-\/length.~\newline
 The \mbox{\hyperlink{class_ramp}{Ramp}} is a single descending ramp (with a 90° angle).~\newline
 The \mbox{\hyperlink{class_v_stepper}{V\+Stepper}} is a more complex terrain where the obstacle is kind of a stepper but with sharper angle (angle $<$ 90°).~\newline
 \hypertarget{index_ex_terrain}{}\subsection{Existing terrain}\label{index_ex_terrain}
To select which terrain should be used in the simulation, it has to be specified in the \mbox{\hyperlink{_demo_8h}{Demo.\+h}} file\+: the type of the Demo\+::m\+\_\+terrain member has to be adapted. Once the terrain has been chosen, the terrain Parameters (cf s\+Terrain struct in \mbox{\hyperlink{_config_8h}{Config.\+h}}) can be adjusted using different methods described in \mbox{\hyperlink{index_param}{Configuration parameters}}\hypertarget{index_new_terrain}{}\subsection{Create new terrain}\label{index_new_terrain}
If the creation of a new terrain is necessary, the new class should inherit from the global \mbox{\hyperlink{class_terrain}{Terrain}} class. then the newly created .h file should be included in \mbox{\hyperlink{_demo_8h}{Demo.\+h}}.~\newline
 It might be necessary to re-\/implement the get\+Scale() function depending on the parameters so that the whole terrain fits the window size.~\newline
\hypertarget{index_rob}{}\section{Create robots}\label{index_rob}
The robot flow is either by a given delay between the robots and initial position or a given distance between the robots and phase shift. The way the robots are created is controlled in the Demo.\+cpp file by choosing which function is used in \mbox{\hyperlink{class_demo_a938c3b6ab1c98ce43f977dda9d4f2b3a}{Demo\+::demo\+Loop()}}. It can be either \mbox{\hyperlink{class_demo_a4636f708574c6be85334ff16373e2292}{Demo\+::add\+Robot\+With\+Delay()}} to control the robot creation with a given delay or \mbox{\hyperlink{class_demo_a37b03d288a1bf67f586cdfe1f9ba16af}{Demo\+::add\+Robot\+With\+Distance()}} to control the robot creation with a given distance. Then the distance, delay, phase, initial position are specified in the s\+Simulation \mbox{\hyperlink{index_param}{Configuration parameters}}. ~\newline
 \hypertarget{index_rob_del}{}\subsection{Custom robot delay distribution}\label{index_rob_del}
By default, the delay (or distance) between the robots follow a constant distribution (ie the distance/ delay is identical between every successive robots). In certain cases, it can be interesting to customize the distribution for example to study the introduction of perturbation. A way to do so without modifying to much the code structure is to update m\+\_\+config.\+simulation.\+robot\+\_\+delay (respectively m\+\_\+config.\+simulation.\+robot\+\_\+distance) directly in the Demo.\+cpp file at every timestep (either within a newly created function or directly in the \mbox{\hyperlink{class_demo_a938c3b6ab1c98ce43f977dda9d4f2b3a}{Demo\+::demo\+Loop()}} one).~\newline
 ~\newline
 Currently, two different delay distribution have been briefly implemented\+:
\begin{DoxyItemize}
\item Gaussian delay\+: the gaussian delay is selected by setting gaussian\+\_\+delay to true at the top of the Demo.\+cpp file.
\end{DoxyItemize}

\begin{DoxyNote}{Note}
Future work might require to properly implement a function which would allow to choose the delay distribution. Maybe, the creation of a robot delay class can be considered.
\end{DoxyNote}
\hypertarget{index_rules}{}\section{Change the rules}\label{index_rules}
The rules can be adapted at several positions
\begin{DoxyItemize}
\item The limit angle to avoid pushing is given as a \mbox{\hyperlink{index_param}{Configuration parameters}} and can be changed the usual way.
\end{DoxyItemize}\hypertarget{index_design}{}\section{Design details}\label{index_design}

\begin{DoxyItemize}
\item The minimum angle before which no gripper can be created (to avoid re-\/gripping the exact same position) can be changed in the \mbox{\hyperlink{class_robot_controller}{Robot\+Controller}} Class by changing the value of the m\+\_\+angle\+\_\+min member
\item gripping area
\item max number of grippers per foot
\item mobility in bridge state
\end{DoxyItemize}\hypertarget{index_ex}{}\section{Step by Step example}\label{index_ex}
As briefly explained in the \mbox{\hyperlink{index_struct}{Code overview}}, currently, the simulation should be adapted by changing directly the main function of the \mbox{\hyperlink{main_8cpp}{main.\+cpp}} file and adapt the Demo.\+cpp / \mbox{\hyperlink{_demo_8h}{Demo.\+h}} files. The basic steps are described below

In \mbox{\hyperlink{main_8cpp}{main.\+cpp}} \+: 
\begin{DoxyCode}
\textcolor{keywordtype}{int} \mbox{\hyperlink{main_8cpp_a0ddf1224851353fc92bfbff6f499fa97}{main}}(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}* argv[])
\{

 \textcolor{comment}{// Declaration and initialization of the variables}
 \textcolor{keywordtype}{bool} config\_file = \textcolor{keyword}{false};
 std::string config\_file\_path;
 \mbox{\hyperlink{structconfig_1_1s_config}{config::sConfig}} configParam;
 \mbox{\hyperlink{main_8cpp_a075854c1227ffd274988d62bb5c859a1}{default\_parameters}}(configParam);

 \textcolor{comment}{// The first step is to create the Box2D world (and choose the gravity)}
 b2Vec2 Gravity(0.f, 0.f);
 b2World* world = \textcolor{keyword}{new} b2World(Gravity);

 \textcolor{comment}{// The second step is to parse the arguments. This function is generic and should not be changed}
 \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < argc; i++) \{ \textcolor{comment}{/* We will iterate over argv[] to get the parameters stored inside.}
\textcolor{comment}{                                      * Note that we're starting on 1 because we don't need to know the}
\textcolor{comment}{                                      * path of the program, which is stored in argv[0] */}
     \textcolor{keywordflow}{if} (std::string(argv[i]) == \textcolor{stringliteral}{"-h"} || std::string(argv[i]) == \textcolor{stringliteral}{"--help"}) \{
       printf(\textcolor{stringliteral}{"tetetete \(\backslash\)n"});
       \mbox{\hyperlink{main_8cpp_a97ee70a8770dc30d06c744b24eb2fcfc}{help}}();
       \textcolor{keywordflow}{return} 0;
     \}
     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (i + 1 != argc)\{
              \textcolor{comment}{// The first thing to check is whether a configuration file has been specified}
       \textcolor{keywordflow}{if} (std::string(argv[i]) == \textcolor{stringliteral}{"-cp"} || std::string(argv[i]) == \textcolor{stringliteral}{"--configuration\_path"}) \{
              \textcolor{comment}{// We know the next argument *should* be the filename:}
              config\_file\_path = std::string(argv[i + 1]);
               config\_file = \textcolor{keyword}{true};
                load\_config(config\_file\_path, configParam);
                 \textcolor{keywordflow}{break};
       \}
       \textcolor{keywordflow}{else}\{
         parse\_argument(argv, i, configParam);
       \}
     \}

     \textcolor{keywordflow}{if}(configParam.terrain.v\_angle > 0)\{
       configParam.terrain.v\_width = tan(configParam.terrain.v\_angle)*2*configParam.terrain.v\_height;
     \}
 \}

 \textcolor{comment}{//The third step is to create the Demo, initiate it, launch it and write the results once it's finished}
 \mbox{\hyperlink{class_demo}{Demo}} myDemo(world, configParam);
 myDemo.init();
 myDemo.demoLoop();
 myDemo.writeResultFile();

 \textcolor{keywordflow}{return} 0;
\}
\end{DoxyCode}


In \mbox{\hyperlink{_demo_8h}{Demo.\+h}}\+: change the terrain type 
\begin{DoxyCode}
\mbox{\hyperlink{class_box_terrain}{BoxTerrain}} m\_terrain; \textcolor{comment}{//Terrain used to do the simulation, the object can be changed to either:
       Terrain, BoxTerrain, Vterrain, V2BLTerrain, VStepper}
\end{DoxyCode}


In Demo.\+cpp\+: choose how the robots are created in the \mbox{\hyperlink{class_demo_a938c3b6ab1c98ce43f977dda9d4f2b3a}{Demo\+::demo\+Loop()}} \+: either with a given distance or a given delay in the main demo\+Loop. Be careful, you have to change at two distinct positions\+: in the first part of the loop when the visualization is activated and in the second part of the loop when the visualization is deactivated 
\begin{DoxyCode}
     \textcolor{comment}{//This is where the traffic control is defined: either using addRobotWithDelay() or
       addRobotWithDistance()}
                \textcolor{keywordflow}{if}(!addRobotWithDelay())\{
                    m\_stacking = \textcolor{keyword}{true};
                    printf(\textcolor{stringliteral}{"robot stacking \(\backslash\)n"});
\textcolor{comment}{//                  m\_bridgeFile.close();}
                    \textcolor{keywordflow}{continue};
                \}
\end{DoxyCode}
 